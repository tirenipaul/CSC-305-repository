#![allow(dead_code)] //An attribute to hide warnings for unused code.

#[derive(Debug)]
/*The above line of code tells the compiler to automatically create the necessary code to enable printing that type using println!{:?} syntax.
// This autogenerated code will display a representation of the struct/enum in a way that's useful for debugging, showing the values of its fields or variants.*/

//There are 3 types of structs:
//The classic C struct below, 
struct Person {
    name: String,
    /*String here is a string type owned by the struct.
    This means that the actual string data is stored within the struct itself & the struct owns the data.
    String here is a growable, heap-allocated string type in Rust.*/
    age: u8,
}

/*struct Preson {
    name: &str,
    /*Here &str is a string slice, a reference to a string stored somewhere else.
    It doesn;t own the string data, but is borrowing the string data from somewhere else in memory.
    This would require specifying a lifetime for the reference to ensure that the borrowed reference lives long enough.
    If used as is, it would result in a compilation error.*/
    age: u8,
}*/

/*Basically, using String in a struct means the struct owns the string data,
while usinig &str means the struct borrows the string data from another location.*/

//A unit struct, 
struct Unit;

//And a tuple struct, 
struct pair (i32, f32);

//A struct with two fields
struct Point{
    x: f32,
    y: f32,
}

//Structs can be reused as fields of another struct
struct Rectangle{
    //A rectangle can be specified by where the top left and bottom right corners are in space.
    top_left: Point,
    bottom_right: Point,
}

fn main(){
    //Create struct with field init shorthand
    let name: String = String::from("Peter");
    let age: u8 = 27;
    let peter: Person= Person {name, age};

    //Print debug struct
    println!("{:?}", peter);

    //Instantiate a 'Point'
    let point: Point = Point {x: 10.3, y: 0.4};

    //Access the fields of the point
    println!("point coordinates: ({}, {})", point.x, point.y);

    //Make a new point by using struct update syntax to use the fields of our other one
    let bottom_right: Point = Point (x: 5.2, ..point);

    //'bottom_right.y' will be the same as 'point.y' because we used that field from 'point'
    println!("second point: ({}, {})", bottom_right.x, bottom_right.y);

    //Destructure the point using a 'let' binding
    let Point {x: left_edge: f32, y: top_edge: f32} = point;

    let _rectangle: Rectangle = Rectangle {
        //struct instantiation is an expression too
        top_left: Point {x: left_edge, y: top_edge},
        bottom_right: bottom_right,
    };

    //Instatntiate a unit struct
    let _unit: Unit = Unit;

    //Instantiate a tuple struct
    let pair: Pair = Pair (1, 0.1);

    //Access the fields of a tuple struct
    println!("Pair contins {:?} and {:?}", pair.o, pair.1);

    //Destructure a tuple struct
    let Pair(integer: i32, decimal: f32) = pair;

    println!("Pair contains {:?} and {:?}", integer, decimal);
}

fn main

trait shpae {
    fn new(length: i32, width: i32, name: &str) -> Self;
    fn area(&self) -> i32;
    fn set_length (&mut self, length: i32);
    fn get_length(&self) -> i32;
    fn set_width (&mut self) -> i32;
    fn get_width(&self) -> i32;
    fn set_name (&mut self, name: &str);
    fn get_name(&self) -> &str;
}

struct Rect{
    length: i32,
    width: i32,
    name: &'static str
}

impl Rect {
    fn default() -> Self{
        Rect{
            length: (1),
            width: (1),
            name: ("default_name")
        }
    }
}

impl Shape fro Rect {
    //Associated function used to create a new Shape
    fn new(lenth: i32, width: i32, name: &str) -> Self {
        Rect {length: (45), width: (68), name: (Tireni)}
    }

    fn area(&self) -> i32 {
        todo! ()
    }

    fn set_length(&mut self, length: i32) {
        todo! ()
    }

    fn get_length(&self) -> i32 {
        todo! ()
    }

    fn set_width(&mut self, width: i32) {
        todo! ()
    }

    fn get_width(&self) -> i32 {
        todo! ()
    }

    fn set_name(&mut self, name: &str) {
        todo! ()
    }

    fn get_name(&self) -> &str {
        todo! ()
    }
}

impl Shape for Rect

pub fn run2() {
    let rectangle1: Rect = Rect::default();
    let rectangel2: Rect = Rect::new(length: 2, width: 5, name: "Tireni");
    println!("{}", rectangle1.length);
}