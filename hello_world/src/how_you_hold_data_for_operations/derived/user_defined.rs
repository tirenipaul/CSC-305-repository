/*#![allow(dead_code)] //An attribute to hide warnings for unused code.

#[derive(Debug)]
/*The above line of code tells the compiler to automatically create the necessary code to enable printing that type using println!{:?} syntax.
// This autogenerated code will display a representation of the struct/enum in a way that's useful for debugging, showing the values of its fields or variants.*/

//There are 3 types of structs:
//The classic C struct below, 
struct Person {
    name: String,
    /*String here is a string type owned by the struct.
    This means that the actual string data is stored within the struct itself & the struct owns the data.
    String here is a growable, heap-allocated string type in Rust.*/
    age: u8,
}

/*struct Preson {
    name: &str,
    /*Here &str is a string slice, a reference to a string stored somewhere else.
    It doesn;t own the string data, but is borrowing the string data from somewhere else in memory.
    This would require specifying a lifetime for the reference to ensure that the borrowed reference lives long enough.
    If used as is, it would result in a compilation error.*/
    age: u8,
}*/

/*Basically, using String in a struct means the struct owns the string data,
while usinig &str means the struct borrows the string data from another location.*/

//A unit struct, 
struct Unit;

//And a tuple struct, 
struct pair (i32, f32);

//A struct with two fields
struct Point{
    x: f32,
    y: f32,
}

//Structs can be reused as fields of another struct
struct Rectangle{
    //A rectangle can be specified by where the top left and bottom right corners are in space.
    top_left: Point,
    bottom_right: Point,
}

fn main(){
    //Create struct with field init shorthand
    let name: String = String::from("Peter");
    let age: u8 = 27;
    let peter: Person= Person {name, age};

    //Print debug struct
    println!("{:?}", peter);

    //Instantiate a 'Point'
    let point: Point = Point {x: 10.3, y: 0.4};

    //Access the fields of the point
    println!("point coordinates: ({}, {})", point.x, point.y);

    //Make a new point by using struct update syntax to use the fields of our other one
    let bottom_right: Point = Point (x: 5.2, ..point);

    //'bottom_right.y' will be the same as 'point.y' because we used that field from 'point'
    println!("second point: ({}, {})", bottom_right.x, bottom_right.y);

    //Destructure the point using a 'let' binding
    let Point {x: left_edge: f32, y: top_edge: f32} = point;

    let _rectangle: Rectangle = Rectangle {
        //struct instantiation is an expression too
        top_left: Point {x: left_edge, y: top_edge},
        bottom_right: bottom_right,
    };

    //Instatntiate a unit struct
    let _unit: Unit = Unit;

    //Instantiate a tuple struct
    let pair: Pair = Pair (1, 0.1);

    //Access the fields of a tuple struct
    println!("Pair contins {:?} and {:?}", pair.o, pair.1);

    //Destructure a tuple struct
    let Pair(integer: i32, decimal: f32) = pair;

    println!("Pair contains {:?} and {:?}", integer, decimal);
}

fn main

trait shpae {
    fn new(length: i32, width: i32, name: &str) -> Self;
    fn area(&self) -> i32;
    fn set_length (&mut self, length: i32);
    fn get_length(&self) -> i32;
    fn set_width (&mut self) -> i32;
    fn get_width(&self) -> i32;
    fn set_name (&mut self, name: &str);
    fn get_name(&self) -> &str;
}

struct Rect{
    length: i32,
    width: i32,
    name: &'static str
}

impl Rect {
    fn default() -> Self{
        Rect{
            length: (1),
            width: (1),
            name: ("default_name")
        }
    }
}

impl Shape fro Rect {
    //Associated function used to create a new Shape
    fn new(lenth: i32, width: i32, name: &str) -> Self {
        Rect {length: (45), width: (68), name: (Tireni)}
    }

    fn area(&self) -> i32 {
        todo! ()
    }

    fn set_length(&mut self, length: i32) {
        todo! ()
    }

    fn get_length(&self) -> i32 {
        todo! ()
    }

    fn set_width(&mut self, width: i32) {
        todo! ()
    }

    fn get_width(&self) -> i32 {
        todo! ()
    }

    fn set_name(&mut self, name: &str) {
        todo! ()
    }

    fn get_name(&self) -> &str {
        todo! ()
    }
}

impl Shape for Rect

pub fn run2() {
    let rectangle1: Rect = Rect::default();
    let rectangel2: Rect = Rect::new(length: 2, width: 5, name: "Tireni");
    println!("{}", rectangle1.length);
}*/

#![allow(dead_code)] //This suppresses warnings when a given declared function is  not used.
#[allow(unused_variables)]

use core::cmp::Ordering; //Used dor comparison of value sizes 

pub enum Comp { //Enumerate Comparison
    LessThan,
    GreaterThan,
    Equal,
}

pub enum Gender { //Enumerate Gender
    Male,
    Female,
}

#[derive(Debug)] //Decorate the struct Person. Debug is an inbuilt trait. This statement will provoke impl Debug for Person; Metaprogramming
struct Person {
    name: String,
    age: u8,
}
struct Unit;
// A unit struct
//Have no state of their own but useful for
//implementing some trait.
//E.g. struct Global is a unit struct that can implement traits like Allocator
//std::fmt::Error is a unit struct that implements
//traits like Error

//A tuple struct
struct Pair(i32, f32); //No named fields but has fields

//A struct with two fields
struct Point {
    x: f32,
    y: f32,
}

// Structs can be reused as fields of another struct. Below Point is used as datatype in Rectangle
struct Rectangle {
    top_left: Point,
    bottom_right: Point,
}

pub fn run() {

    //declare a variable of type Person and assign values.
    let person = Person {
        name: String::from("Peter"),
        age: 27,
    };
    println!("{:#?}", person); //{:#?} implies pretty debug print person. :? is for debug print and :#? is for pretty debug print

    // Instantiate a unit struct
    let _unit = Unit;//As simple as that. If Unit implements some trait, then _unit will demand those implementations

    //declare a Point
    let point = Point { x: 10.3, y: 0.4 };

    //Access the fields of the point
    println!("point coordinates: ({}, {})", point.x, point.y);

    // Make a new point by using struct update syntax to use the fields of our
    // other one
    let bottom_right = Point { x: 5.2, ..point };
    // `bottom_right.y` will be the same as `point.y` because we used that field
    // from `point`
    println!("second point: ({}, {})", bottom_right.x, bottom_right.y);

    // Destructure the point using a let binding.
    let Point {
        x: left_edge,//left_edge here will be declared. If you use x:f32 only, x will be declared.
        y: top_edge,//top_edge here will be declared. If you use y:f32 only, y will be declared.
    } = point;
    dbg!(&left_edge,&top_edge);


    let _rectangle = Rectangle { //I used _ with rectangle to silence warning knowing that the variable is not used.
        //struct instantiation is an expression too as used below in Point
        top_left: Point {
            x: left_edge,//left_edge is available, thanks to the destructuring above
            y: top_edge,//top_edge is available, thanks to the destructuring above
        },
        bottom_right,
    };

    //Instantiate a tuple struct
    let pair = Pair(1, 0.1);
    //Access the fields of a tuple struct
    println!("pair contains {:?} and {:?}", pair.0, pair.1);

    //Destructure a tuple struct
    let Pair(integer, decimal) = pair;
    println!("pair contains {:?} and {:?}", integer, decimal);
}

//Let's work on user-defined traits. Traits enable us achieve polymorphism.
//We are designing Shape below for the purpose of 
//specifying all expected functions and methods in any struct that implements Shape.
trait Shape {
    fn new(length: i32, width: i32, sidec: i32, name: &'static str) -> Self;
    //fn new2(sidea: i32, sideb: i32, sidec: i32, name: &'static str) -> Self;
    //fn new3(radius: i32, /*diameter: i32,*/ name: &'static str) -> Self;
    fn area(&self) -> i32;
    fn perimeter(&self) -> i32;
    fn set_length(&mut self, length: i32);
    fn get_length(&self) -> i32;
    fn set_width(&mut self, width: i32);
    fn get_width(&self) -> i32;
    fn set_sidec(&mut self, sidec: i32);
    fn get_sidec(&self) -> i32;
    //fn set_diameter(&mut self, diameter: i32);
    //fn get_diameter(&self) -> i32;
    fn set_name(&mut self, name: &'static str);
    fn get_name(&self) -> &str;
}
//The use of 'static lifetime above ensures that our
//compiler is clear about the availability of those values, as they are borrowed.
//static will be available throughout the lifetime of the program.

///Use Default to specify the availability of default instance creation without values passed for property
#[derive(Default, Debug, Clone)]
struct Rect {
    length: i32,
    width: i32,
    name: &'static str,
}

impl Rect {
    //default default() function. Will override derived default if any. 
    fn default() -> Self {
        Rect {
            length: 1,
            width: 1,
            name: "default_name",
        }
    }
}

impl Shape for Rect {
    //Associated function used to create a new Shape
    fn new(length: i32, width: i32, sidec: i32, name: &'static str) -> Self {
        Rect {
            length,
            width,
            name,
        }
    }

    fn area(&self) -> i32 {
        self.length * self.width
    }

    fn perimeter(&self) -> i32 {
        (self.length + self.width) * 2
    }

    fn set_length(&mut self, length: i32) {
        self.length = length;
    }

    fn get_length(&self) -> i32 {
        self.length
    }

    fn set_width(&mut self, width: i32) {
        self.width = width;
    }

    fn get_width(&self) -> i32 {
        self.width
    }

    fn set_sidec(&mut self, sidec: i32){
        //Ignoring sidec for Rectangle
    }

    fn get_sidec(&self) -> i32{
        //Ignoring sidec for Rectangle
        0
    }

    fn set_name(&mut self, name: &'static str) {
        self.name = name;
    }

    fn get_name(&self) -> &str {
        self.name
    }
}

//implement Partial Eq
impl PartialEq for Rect {
    fn eq(&self, other: &Self) -> bool {
        self.area() == other.area()
    }

    fn ne(&self, other: &Self) -> bool {
        !self.eq(other)
    }
}

//A conversion implementation into String. Can be used to move the variable into another
/*impl Into<String>  for Rect{
fn into (self) -> String {
    //Let's return a string template literal.
    println!("My name is {} and my area is {}.", self.name, self.area)
}
}

struct Circler{
    radius: f32
}

impl Into <Circler> for Rect{
    fn into (self) -> Circler{
        //radius = sqrt of (A/ pi)
        /*let pi = 22/7;
        let rad = self: self.area / pi;
        let radius = sqrt(rad)*/
     let radius: f32 = f32::sqrt(self.area() as f32/3.14);
     Circler(radius);
    }

}*/



impl PartialOrd for Rect {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        // Implementing PartialOrd for Rectangle based on area and perimeter
        match (self.area().partial_cmp(&other.area()), self.perimeter().partial_cmp(&other.perimeter())) {
            (Some(area_cmp), Some(perimeter_cmp)) => {
                if area_cmp == Ordering::Equal && perimeter_cmp == Ordering::Equal {
                    Some(Ordering::Equal)
                } else {
                    Some(area_cmp.then_with(|| perimeter_cmp))
                }
            }
            _ => None, // Return None if any of the comparisons return None
        }
    }
    // Provided methods
    //fn lt(&self, other: &Rhs) -> bool { ... }
    //fn le(&self, other: &Rhs) -> bool { ... }
    //fn gt(&self, other: &Rhs) -> bool { ... }
    //fn ge(&self, other: &Rhs) -> bool { ... }
}


//A conversion implementation into String
//Expects a string slice with length, width, name, separated by commas
impl From<&'static str> for Rect {
    fn from(s: &'static str) -> Rect {
        let mut parts = s.split(',');
        let length = match parts.next() {
            Some(val) => val.parse::<i32>().unwrap(),
            None => 0,
        };
        let width = match parts.next() {
            Some(val) => val.parse::<i32>().unwrap(),
            None => 0,
        };
        let name = match parts.next() {
            Some(val) => val,
            None => "",
        };
        Rect { length, width, name: &name }
    }
}

pub fn run2() {
    let rectangle1 = Rect::default();
    
    println!("The length of the default Rectangle is: {}", rectangle1.length);
    println!("The width of the default Rectangle is: {}", rectangle1.width);
    println!("The name of the default Rectangle is: {}", rectangle1.name);
    println!("Area of  Rectangle is: {}", rectangle1.area());
    println!("Perimeter of Rectangle is: {}", rectangle1.perimeter());

    let rectangle2: Rect = Rect::new(1, 3, 0, "Rectangle2");
    let rectangle3: Rect = Rect::from("4,5,Rectangle3");

    //Compare using PartialOrd
    let result1 = rectangle1.partial_cmp(&rectangle2);
    println!("result1 = {:?}", result1);

    let result2 = rectangle1.le(&rectangle2);
    println!("result2 = {:?}", result2);

    //Compare using PartialEq
    let result3 = rectangle2.eq(&rectangle3);
    println!("result3 = {:?}", result3);

    let result4 = rectangle2.ne(&rectangle3);
    println!("result4 = {:?}", result4);
}

//Exercise
/*
I need similar implementation for Circle and Triangle
Besides Area, I need Perimeter and comparison on the basis of Perimeter
In your submission, I need a comment against every line of code about what it is mearnt to achieve
 */


//Creating a Circle struct 
struct Circle {
    //parameters of the circle struct
    radius: i32,
    name: &'static str,
}

impl Circle {
    //default default() function. Will override derived default if any. 
    fn default() -> Self {
        Circle {
            radius: 1,
            name: "CIRCLE",
        }
    }
}

//Creating a Triangle struct
struct Triangle {
    //parameters of the triangle struct
    length: i32,
    width: i32,
    sidec: i32,
    name: &'static str,
}

impl Triangle {
    //default default() function. Will override derived default if any. 
    fn default() -> Self {
        Triangle {
            length: 5,
            width: 5,
            sidec: 5,
            name: "TRIANGLE",
        }
    }
}

// Implementation of the Shape trait for Circle
impl Shape for Circle {
    //Associated function used to create a new circle by using the traits of Shape
    fn new(_length: i32, _width: i32,  sidec: i32, name: &'static str) -> Self {
        //Specifying the traits circle is going to be using from trait.
        Circle {
            radius: 0,
            name,
        }
    }

    //Function to calculate the area of circle and return the result of this calculation as type i32
    fn area(&self) -> i32 {
        let pi = 22/7;
        pi * self.radius * self.radius

        /*OR if diameter is specified instead
        pi * self.diameter*/
    }

    //Function to calculate the perimeter of circle and return the result of this calculation as type i32
    fn perimeter(&self) -> i32{
        let pi = 22/7;
        2*pi*self.radius
    }

    fn set_length(&mut self, length: i32) {
        //Ignoring sidec for Circle as its not being used
    }

    fn get_length(&self) -> i32 {
        //Ignoring sidec for Circle
        0
    }

    fn set_width(&mut self, width: i32) {
        //Ignoring sidec for Circle
    }

    fn get_width(&self) -> i32 {
        //Ignoring width for Rectangle
        0
    }

    fn set_sidec(&mut self, sidec: i32){
        //Ignoring sidec for Circle
    }

    fn get_sidec(&self) -> i32{
        //Ignoring sidec for Circle
        0
    }

    fn set_name(&mut self, name: &'static str) {
        self.name = name;
    }

    fn get_name(&self) -> &str {
        self.name
    }
    
}

impl PartialEq for Circle {
    fn eq(&self, other: &Self) -> bool {
        // Implementing PartialEq for Circle based on area and perimeter
        if let (Some(area_cmp), Some(perimeter_cmp)) = (self.area().partial_cmp(&other.area()), self.perimeter().partial_cmp(&other.perimeter())) {
            area_cmp == Ordering::Equal && perimeter_cmp == Ordering::Equal
        } else {
            false // Return false if any of the comparisons return None
        }
    }

    fn ne(&self, other: &Self) -> bool {
        // Implementing != for Circle based on PartialEq
        !self.eq(other)
    }
}

impl PartialOrd for Circle {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        // Implementing PartialOrd for Circle based on area and perimeter
        match (self.area().partial_cmp(&other.area()), self.perimeter().partial_cmp(&other.perimeter())) {
            (Some(area_cmp), Some(perimeter_cmp)) => {
                if area_cmp == Ordering::Equal && perimeter_cmp == Ordering::Equal {
                    Some(Ordering::Equal)
                } else {
                    Some(area_cmp.then_with(|| perimeter_cmp))
                }
            }
            _ => None, // Return None if any of the comparisons return None
        }
    }
}

// From trait implementation for Circle, similar to Rect
impl From<&'static str> for Circle {
    fn from(s: &'static str) -> Circle {
        // Split the input string by commas
        let mut parts = s.split(',');
        
        // Extract the radius from the first part of the split string
        let radius = match parts.next() {
            Some(val) => val.parse::<i32>().unwrap_or(0), // Parse the value as f32 or default to 0.0 if parsing fails
            None => 0, // Set default radius to 0.0 if no value is present
        };
        
        // Extract the name from the second part of the split string
        let name = match parts.next() {
            Some(val) => val,
            None => "", // Set default name to an empty string if no value is present
        };
        
        // Create and return a new Circle instance using the extracted values
        Circle { radius, name }
    }
}

pub fn run_circle() {
    //Function to print all result for circle
    let circle1 = Circle::default();
    
    println!("Radius: {}", circle1.radius);
    println!("Name: {}", circle1.name);
    println!("Area of Circle is: {}", circle1.area());
    println!("Perimeter of Circle is: {}", circle1.perimeter());

    let circle2 = Circle::new(4, 0, 0, "Circle2");
    let circle3 = Circle::from("5,Circle3");

    // Compare using PartialOrd
    let result1 = circle1.partial_cmp(&circle2);
    println!("Result 1 = {:?}", result1);

    let result2 = circle1.le(&circle2);
    println!("Result 2 = {:?}", result2);

    // Compare using PartialEq
    let result3 = circle2.eq(&circle3);
    println!("Result 3 = {:?}", result3);

    let result4 = circle2.ne(&circle3);
    println!("Result 4 = {:?}", result4);
}



impl Shape for Triangle {
    //Associated function used to create a new circle by using the traits of Shape
    fn new(length: i32, width: i32, sidec: i32, name: &'static str) -> Self {
        Triangle {
            length: 0,
            width: 0,
            sidec: 0,
            name,
        }
    }

    fn area(&self) -> i32 {

        //Calculating area of triangle
               let s = (self.length + self.width + self.sidec) / 2;
               let d: f64 = (s * (s - self.length) * (s - self.width) * (s - self.sidec)).into();
               let square_root = (d as f64).sqrt();
               square_root as i32

            /*if self.length == self.width && self.width == self.sidec {
                let root : i32 = 3;
                (sqrt(root) / 4) * self.length;
            }
            else if (self.length == self.width) | (self.length == self.sidec) | (self.width == self.sidec){
                if self.length == self.width{
                    let half: i32 = 1/2 * self.sidec;
                    let deter = (self.length * self.length) - ((half * half)/ 4);
                    1/2 * half * sqrt(deter)
                }
                else if self.length == self.sidec{
                    let half: i32 = 1/2 * self.width;
                    let deter = (self.length * self.length) - ((half * half)/ 4);
                    1/2 * half * sqrt(deter)
                }
                else if self.width == self.sidec{
                    let half: i32 = 1/2 * self.length;
                    let deter = (self.width * self.width) - ((half * half)/ 4);
                    1/2 * half * sqrt(deter)
                }
            }
            else{
               let s = (self.length + self.width + self.sidec) / 2.0;
               (s * (s - self.side1) * (s - self.side2) * (s - self.side3)).sqrt() as i32
            }*/
            
        
    }

    fn perimeter (&self) -> i32 {
        (self.length + self.width + self.sidec) as i32

    }

    fn set_length(&mut self, length: i32) {
        self.length = length;
    }

    fn get_length(&self) -> i32 {
        self.length
    }

    fn set_width(&mut self, width: i32) {
        self.width = width as i32;
    }

    fn get_width(&self) -> i32 {
        self.width
    }

    fn set_sidec(&mut self, sidec: i32){
        self.sidec = sidec as i32
    }

    fn get_sidec(&self) -> i32{
        self.sidec
    }

    fn set_name(&mut self, name: &'static str) {
        self.name = name;
    }

    fn get_name(&self) -> &str {
        self.name
    }
}

impl PartialEq for Triangle {
    fn eq(&self, other: &Self) -> bool {
        // Implementing PartialEq for Triangle based on area and perimeter
        if let (Some(area_cmp), Some(perimeter_cmp)) = (self.area().partial_cmp(&other.area()), self.perimeter().partial_cmp(&other.perimeter())) {
            area_cmp == Ordering::Equal && perimeter_cmp == Ordering::Equal
        } else {
            false // Return false if any of the comparisons return None
        }
    }

    fn ne(&self, other: &Self) -> bool {
        // Implementing != for Triangle based on PartialEq
        !self.eq(other)
    }
}

impl PartialOrd for Triangle {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        // Implementing PartialOrd for Triangle based on area and perimeter
        match (self.area().partial_cmp(&other.area()), self.perimeter().partial_cmp(&other.perimeter())) {
            (Some(area_cmp), Some(perimeter_cmp)) => {
                if area_cmp == Ordering::Equal && perimeter_cmp == Ordering::Equal {
                    Some(Ordering::Equal)
                } else {
                    Some(area_cmp.then_with(|| perimeter_cmp))
                }
            }
            _ => None, // Return None if any of the comparisons return None
        }
    }
}

// From trait implementation for Circle, similar to Rect
impl From<&'static str> for Triangle {
    fn from(s: &'static str) -> Triangle {
        // Split the input string by commas
        let mut parts = s.split(',');
        
        // Extract the side lengths from the split string
        let length = match parts.next() {
            Some(val) => val.parse::<i32>().unwrap_or(0), // Parse the value as i32 or default to 0 if parsing fails
            None => 0, // Set default side1 to 0 if no value is present
        };
        let width = match parts.next() {
            Some(val) => val.parse::<i32>().unwrap_or(0), // Parse the value as i32 or default to 0 if parsing fails
            None => 0, // Set default width to 0 if no value is present
        };
        let sidec = match parts.next() {
            Some(val) => val.parse::<i32>().unwrap_or(0), // Parse the value as i32 or default to 0 if parsing fails
            None => 0, // Set default side3 to 0 if no value is present
        };
        
        // Extract the name from the fourth part of the split string
        let name = match parts.next() {
            Some(val) => val,
            None => "", // Set default name to an empty string if no value is present
        };
        
        // Create and return a new Triangle instance using the extracted values
        Triangle { length, width, sidec, name }
    }
}

pub fn run_triangle() {
    //Function to print results of the area, perimeter, side lengths, partial order & partial comparison
    let triangle1 = Triangle::default();
    
    println!("Triangle Side1: {}", triangle1.length);
    println!("Triangle Side2: {}", triangle1.width);
    println!("Triangle Side3: {}", triangle1.sidec);
    println!("Name: {}", triangle1.name);
    println!("Area of Triangle is: {}", triangle1.area());
    println!("Perimeter of Triangle is: {}", triangle1.perimeter());

    let triangle2 = Triangle::new(3, 4, 5, "Triangle2");
    let triangle3 = Triangle::from("6.0,7.0,8.0,Triangle3");

    // Compare using PartialOrd
    let result1 = triangle1.partial_cmp(&triangle2);
    println!("Result 1 = {:?}", result1);

    let result2 = triangle1.le(&triangle2);
    println!("Result 2 = {:?}", result2);

    // Compare using PartialEq
    let result3 = triangle2.eq(&triangle3);
    println!("Result 3 = {:?}", result3);

    let result4 = triangle2.ne(&triangle3);
    println!("Result 4 = {:?}", result4);
}

fn main(){
    run2();
    run_circle();
    run_triangle()
}

//From and Into are for conversion. Its a way of standardizing the conversion process.
//
